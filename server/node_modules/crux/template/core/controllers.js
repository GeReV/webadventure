/**
 * Handles loading/routing controllers
 *
 * Pattern-based routing based on Sammy
 *   {https://github.com/quirkey/sammy}
 */

var controllers;

// Routing regex components
var PATH_REPLACER = "([^\/]+)";
var PATH_NAME_MATCHER = /:([\w\d]+)/g;

// Are we using pattern routing?
$.config.loadSync('core');
var PATTERN_ROUTING =!! $.config.item('core').pattern_routing;

// Exports
module.exports = controllers = {

	// Stores loaded controllers
	store: { },
	
	// Errors
	noSuchController: 1,
	noSuchRouteFunction: 2,
	invalidMethod: 3,
	invalidScheme: 4,
	
	// Load a controller if needed and return it
	load: function(controller) {
		if (! controllers.store.hasOwnProperty(controller)) {
			// Load the controller from the file
			try {
				controllers.store[controller] = require($.CONTROLLER_PATH + controller);
				$.log.verbose.message('Reading controller file "' + controller + '"');
			} catch (e) {
				if (e instanceof SyntaxError) {
					throw e;
				} else {
					$.log.verbose(e);
				}
			}
			// Parse the controller if needed
			if (PATTERN_ROUTING && controllers.store[controller]) {
				var result = [ ];
				var route, current;
				var cont = controllers.store[controller];
				for (var i in cont) {
					if (cont.hasOwnProperty(i)) {
						// Start buiding the route object
						route = {
							route: i,
							funcs: cont[i],
							params: [ ],
							regex: null
						};
						// Reset just for cleaness
						PATH_NAME_MATCHER.lastIndex = 0;
						// Collect param names
						while ((current = PATH_NAME_MATCHER.exec(i)) !== null) {
							route.params.push(current[1]);
						}
						// Build the matching regex
						route.regex = new RegExp('^' + i.replace(PATH_NAME_MATCHER, PATH_REPLACER) + '$');
						// Add the route object to the result
						result.push(route);
					}
				}
				controllers.store[controller] = result;
			}
		}
		return controllers.store[controller];
	},
	
	// Get the correct routing function for a request
	route: function(handle) {
		// Get our URI segments and do any needed defaulting
		var controller = handle.uriSegment(1) || handle._schemeConfig('default_controller');
		// Get the controller object
		if (controller.indexOf('.') > -1) {
			throw controllers.noSuchController;
		}
		controller = controllers.load(controller);
		// If we couldn't get a controller, throw an error
		if (! controller) {
			throw controllers.noSuchController;
		}
		// Finish the routing based on the needed routing method
		return (PATTERN_ROUTING
			? this._routePattern(handle, controller)
			: {
				params: null,
				func: this._routeFunction(handle, controller)
			}
		);
	},
	
	// Do pattern-based routing
	_routePattern: function(handle, controller) {
		var cont;
		var paramValues;
		var params = { };
		var routeString = handle.uriSlice(2).join('/') || 'index';
		// Loop through the controller methods looking for a match
		for (var i = 0, c = controller.length; i < c; i++) {
			var cont = controller[i];
			if ((paramValues = cont.regex.exec(routeString)) !== null) {
				$.log.verbose('Routing by pattern "' + cont.route + '"');
				// We don't want the first index (the full match)
				paramValues.shift();
				// Build the params object
				paramValues.forEach(function(value, index) {
					params[cont.params[index]] = _decode(value);
				});
				// Return the resulting controller object
				return {
					params: params,
					func: this._routeSchemeMethod(handle, cont.funcs)
				};
			}
		}
		// No match found
		throw controllers.noSuchRouteFunction;
	},
	
	// Do simple (non-pattern) routing
	_routeSimple: function(handle, controller) {	
		var routeFunction = handle.uriSegment(2) || 'index';
		if (! controller[routeFunction]) {
			if (! controller._notFound) {
				throw controllers.noSuchRouteFunction;
			}
			routeFunction = '_notFound';
		}
		return this._routeSchemeMethod(handle, controller[routeFunction]);
	},
	
	// Get the correct function for a controller route object
	_routeSchemeMethod: function(handle, route) {
		// If we already have a function, no more routing is needed
		if (typeof route === 'function') {
			return route;
		}
		// Get the request method
		var method = handle.method.toLowerCase();
		// Route by method...
		if (route[method]) {
			route = route[method];
			$.log.verbose.indented(2, 'Routing by method; found "' + method + '"');
		} else if (route.any) {
			route = route.any;
			$.log.verbose.indented(2, 'Routing by method; found "any"');
		} else {
			throw controllers.invalidMethod;
		}
		// If we have a function, we're done
		if (typeof route === 'function') {
			return route;
		}
		// Otherwise, we are determining by scheme
		var scheme = handle.scheme;
		if (route[scheme]) {
			route = route[scheme];
			$.log.verbose.indented(2, 'Routing by scheme; found "' + scheme + '"');
		} else if (route.any) {
			// This exists both for similarity between method and scheme routing and
			// in case I ever decide to allow schemes other than just HTTP and HTTPS.
			route = route.any;
			$.log.verbose.indented(2, 'Routing by scheme; found "any"');
		} else {
			throw controllers.invalidScheme;
		}
		return route;
	}
	
};

function _decode(str) {
	return decodeURIComponent((str || '').replace(/\+/g, ' '));
}

/* End of file controllers.js */
/* Location: ./core/controllers.js */
