/**
 * Modifys the RequestHandle and Agent prototypes to add input handling
 */

var RequestHandle = require($.CORE_PATH + 'servers').RequestHandle;

var qs = require('querystring');

// ------------------------------------------------------------------
//  URL/URI methods

// Fetches URI segments
RequestHandle.prototype.uriSegment = function(index) {
	return this._uriSegments[index] || null;
};

// Fetches a slice of the uri segments
RequestHandle.prototype.uriSlice = function(start, end) {
	return this._uriSegments.slice(start, end);
};

// ------------------------------------------------------------------
//  Input data methods

// Fetches GET data (async to match POST below)
RequestHandle.prototype.get = function(value, callback) {
	if (typeof value === 'function') {
		callback = value;
		value = null;
	}
	process.nextTick(function() {
		callback(value ? this.url.query[value] : this.url.query);
	});
};

// Fetches POST data (async because it is dependent on waiting for POST data)
RequestHandle.prototype.post = function(value, callback) {
	var self = this;
	if (this.request.method === 'POST') {
		if (typeof value === 'function') {
			callback = value;
			value = null;
		}
		if (! this._post) {
			if (! this._postQueue) {
				this._postQueue = [ ];
				var body = '';
				this.request.on('data', function(data) {
					body += data;
				});
				this.request.on('end', function() {
					var contentType = self.request.headers['content-type'];
					if (contentType === 'application/json') {
						self._post = JSON.parse(body);
					} else if (contentType === 'application/x-www-form-urlencoded') {
						self._post = qs.parse(body);
					} else {
						self._post = body;
					}
					self._postQueue.forEach(function(args) {
						process.nextTick(function() {
							args[1](args[0] ? self._post[args[0]] : self._post);
						});
					});
				});
			}
			this._postQueue.push([value, callback]);
		} else {
			process.nextTick(function() {
				callback(value ? self._post[value] : self._post);
			});
		}
	}
};

// ------------------------------------------------------------------
//  Headers methods

// Fetches a request header
RequestHandle.prototype.requestHeader = function(header) {
	return header ? (this.request.headers[header] || null) : this.headers;
};

// Fetch an array of request headers
RequestHandle.prototype.requestHeaders = function() {
	if (! this._requestHeaders) {
		this._requestHeaders = [ ];
		for (var i in this.request.headers) {
			if (this.request.headers.hasOwnProperty(i)) {
				this._requestHeaders.push([i, this.request.headers[i]]);
			}
		}
	}
	return this._requestHeaders;
};

buildAcceptParser();
buildAcceptParser('Encoding');
buildAcceptParser('Language');
buildAcceptParser('Charset');

// Factory for building methods based around the Accept-* family of request headers
function buildAcceptParser(header) {
	var methodName  = 'accepts' + (header || '');
	var headerName  = 'accept-' + (header || '').toLowerCase();
	var storage     = '_' + headerName;
	// TODO What the fuck is giveArray for??
	RequestHandle.prototype[methodName] = function(type, giveArray) {
		var self = this;
		// Make sure we have parsed the header
		if (! this[storage]) {
			this[storage] = (self.request.headers[headerName] || '').split(',');
			this[storage] = this[storage].map(function(media) {
				media = media.split(';').map(function(segment) {
					return segment.trim();
				});
				var result = media[0].split('/');
				media.slice(1).forEach(function(param) {
					param = param.split('=');
					result[param[0]] = (param[0] === 'q') ? parseFloat(param[1]) : param[1];
				});
				return result;
			});
		}
		// If no Accept values were given, always give true
		if (! this[storage].length) {return true;}
		// Otherwise, loop through the given values and find one that matches
		type = type.split('/');
		var media, found;
		for (var i = 0, c = this[storage].length; i < c; i++) {
			media = this[storage][i];
			// If a */* value is given, always give true
			if (media[0] === '*') {
				if (! found || media[0].q > found.q) {
					found = media;
				}
			}
			// Look for a top-level match, and then a sub-level match
			else if (media[0] === type[0] && (media[1] === type[1] || media[1] === '*')) {
				if (! found || media[0].q > found.q) {
					found = media;
				}
			}
			// If we aren't collecting the array, we can leave after finding a match
			if (! giveArray && found) {return true;}
		}
		return false;
	};
}

/* End of file input.js */
/* Location: ./core/input.js */
