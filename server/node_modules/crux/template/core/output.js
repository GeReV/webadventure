/**
 * Modifys the RequestHandle prototype to add output handling
 */

var RequestHandle = require($.CORE_PATH + 'servers').RequestHandle;

var fs      = require('fs');
var url     = require('url');
var zlib    = require('zlib');
var path    = require('path');
var mime    = require('mime');
var http    = require('http');
var crypto  = require('crypto');

// Send the built response
RequestHandle.prototype.send = function() {
	$.log.indented(1, 'HTTP ' + this._status + '; Content-Type: ' + this.getResponseHeader('content-type')[0]);
	// Compress if needed and acceptable
	if (
		this._content &&
		this._schemeConfig('compress_content') &&
		this.acceptsEncoding('gzip') &&
		! this.getResponseHeader('content-encoding').length
	) {
		var handle = this;
		zlib.gzip(this._content, function(err, result) {
			if (! err) {
				handle.setOutput(result);
				handle.setResponseHeader('Content-Encoding: gzip');
			}
			handle._doSend();
		});
	} else {
		this._doSend();
	}
};

// Send a redirect
RequestHandle.prototype.redirect = function(location, scheme) {
	scheme = scheme || this.scheme;
	location = url.resolve($.config.item(scheme).base_url, location);
	this.status((this.request.httpVersion === '1.0') ? 302 : 303);
	this.setResponseHeader('Location: ' + location);
	this.send();
};

// Actually send the response data stored
RequestHandle.prototype._doSend = function() {
	// Add a content length header if one doesn't exist
	if (! this.getResponseHeader('content-length').length) {
		this.setResponseHeader('Content-Length: ' + this._content.length);
	}
	// Make sure headers are capitalized properly
	formatHeaders(this._headers);
	// Log the response headers
	$.log.indented(2, 'Response Headers');
	$.log.indented(3, this._headers);
	// Send the response
	this.response.writeHead(this._status, this._headers);
	if (this._content) {
		this.response.write(this._content);
	}
	this.response.end();
	// Log the response time
	$.log.indented(2, 'Response Time: ' + ((+new Date()) - this.timestamp) + 'ms');
};

// Set/get the response status
RequestHandle.prototype.status = function(status) {
	if (status) {
		this._status = status;
	}
	return this._status;
};

// Loads a view file
RequestHandle.prototype.loadView = function(view, data, forceFresh, callback) {
	return $.views.load(this, view, data, forceFresh, callback);
};

// Loads a view file synchronously
RequestHandle.prototype.loadViewSync = function(view, data, forceFresh) {
	return $.views.loadSync(this, view, data, forceFresh);
};

// ------------------------------------------------------------------
//  Output control methods

// Loads and outputs a view file
RequestHandle.prototype.renderView = function(view, data, forceFresh, callback) {
	var handle = this;
	var args = Array.prototype.slice.call(arguments);
	var callback = args.pop();
	args.push(function(content) {
		handle.appendOutput(content);
		callback();
	});
	this.loadView.apply(this, args);
};

// Loads and outputs a view file synchronously
RequestHandle.prototype.renderViewSync = function(view, data, forceFresh) {
	this.appendOutput(
		$.views.loadSync(this, view, data, forceFresh)
	);
};

// Set the response content
RequestHandle.prototype.setOutput = function(output) {
	this._content = Buffer.isBuffer(output) ? output : String(output);
};

// Append to the response content
RequestHandle.prototype.appendOutput = function(suffix) {
	var prefix = this._content;
	var prefixIsBuffer = Buffer.isBuffer(prefix);
	var suffixIsBuffer = Buffer.isBuffer(suffix);
	// If the content already set or the new content are buffers, than
	// we have to use buffer concatenation (which doesn't natively exist
	// so we have to fake it).
	if (prefixIsBuffer || suffixIsBuffer) {
		if (! prefixIsBuffer) {
			prefix = new Buffer(prefix);
		}
		if (! suffixIsBuffer) {
			suffix = new Buffer(suffix);
		}
		this._content = new Buffer(
			Array.prototype.slice.call(prefix).concat(
			Array.prototype.slice.call(suffix))
		);
	}
	// In this case, neither value is a buffer, so simple string concat
	// is enough to work
	else {
		this._content += String(suffix);
	}
};

// ------------------------------------------------------------------
//  HTTP Error Handling

// Raise an HTTP error
RequestHandle.prototype.raiseHttpError = function(status, message) {
	var handle = this;
	this.status(status);
	var data = {
		errorStatus: status,
		errorMessage: message,
		errorName: http.STATUS_CODES[status]
	};
	$.views.load(this, 'error', data, function(body) {
		handle.setOutput(body);
		handle.send();
	});
};

RequestHandle.HttpError = function(handle, status, message) {
	this.handle = handle;
	this.status = status;
	this.message = message;
};

RequestHandle.prototype.httpError = function(status, message) {
	return new RequestHandle.HttpError(this, status, message);
};

// ------------------------------------------------------------------
//  Loads files from the /public directory
	
RequestHandle.prototype.loadPublic = function(filepath) {
	var self = this;
	// Resolve the file path to the file
	filepath = filepath || this.url.pathname;
	if (filepath[0] === '/') {
		filepath = filepath.substring(1);
	}
	filepath = $.PUBLIC_PATH + filepath;
	// Check that the requested file exists
	path.exists(filepath, function(exists) {
		if (exists) {
			fs.readFile(filepath, function(err, data) {
				if (err) {
					self.raiseHttpError(404, 'The file requested exists, but could not be read.');
				}
				// Output the file contents
				else {
					self.setResponseHeader('Content-Type: ' + mime.lookup(filepath));
					if (self._schemeConfig('etag_publics')) {
						var etag = etagContent(data);
						// Set the ETag header
						self.setResponseHeader('ETag: ' + etag);
						// Check for a matching If-None-Match header
						var ifNoneMatch = self.requestHeader('if-none-match');
						if (ifNoneMatch === etag) {
							self.status(304);
							self.send();
							return;
						}
					}
					// Send the response
					self.status(200);
					self.setOutput(data);
					self.send();
				}
			});
		}
		// If the file isn't found, raise a 404
		else {
			self.raiseHttpError(404, 'The requested resource does not exist.');
		}
	});
};

// ------------------------------------------------------------------
//  Response header controls

RequestHandle.prototype.responseHeaders = function() {
	return this._headers;
};

RequestHandle.prototype.setResponseHeader = function(value, allowDuplicate) {
	value = (function() {
		var a = value.split(':');
		var b = a.shift();
		var c = a.join(':');
		return [b, c];
	}());
	value[0] = value[0].trim().toLowerCase();
	value[1] = value[1].trim();
	if (! allowDuplicate) {
		this.unsetResponseHeader(value[0]);
	}
	this._headers.push(value);
};

RequestHandle.prototype.getResponseHeader = function(header) {
	var values = this._collectResponseHeaders('with', header);
	for (var i = 0, c = values.length; i < c; i++) {
		values[i] = values[i][1];
	}
	return values;
};

RequestHandle.prototype.unsetResponseHeader = function(header) {
	this._headers = this._collectResponseHeaders('without', header);
};

// Collects an array with or without a given header type
RequestHandle.prototype._collectResponseHeaders = function(withOrWithout, header) {
	var result = [ ];
	var without = (withOrWithout !== 'with');
	header = header.toLowerCase();
	for (var i = 0, c = this._headers.length; i < c; i++) {
		// Both conditions evaluate to booleans in all cases (both come
		// from === operations) so we can XOR them with a !==
		if (without !== (this._headers[i][0] === header)) {
			result.push(this._headers[i]);
		}
	}
	return result;
};

// ------------------------------------------------------------------
//  Helper

function formatHeaders(headers) {
	for (var i = 0, c = headers.length; i < c; i++) {
		headers[i][0] =
			headers[i][0].replace(/(^|-)([a-z])/g, function(match) {
				return match.toUpperCase();
			}
		);
	}
}

function etagContent(content) {
	var shasum = crypto.createHash('sha1');
	shasum.update(content);
	return shasum.digest('hex').substring(0, 8);
}

/* End of file output.js */
/* Location: ./core/output.js */
