/**
 * Create the HTTP(S) server object
 */

$.config.loadSync('http');
$.config.loadSync('https');

var http   = require('http');
var https  = require('https');
var url    = require('url');
var fs     = require('fs');

// Create the actual servers
module.exports = {
	http: (function() {
		if (! $.config.item('http.active')) {
			return null;
		}
		$.log.verbose.message('Starting Http server...');
		// Create the server
		var _server = http.createServer(function(req, res) {
			return handleServerRequest(req, res, 'http');
		});
		// Start listening....
		_server.listen($.config.item('http.port'), $.config.item('http.address'), function() {
			$.log.message('Http server running on ' + $.config.item('http.address') + ':' + $.config.item('http.port'));
		});
		return _server;
	}()),
	https: (function() {
		if (! $.config.item('https.active')) {
			return null;
		}
		$.log.verbose.message('Starting Https server...');
		// Get the server auth options
		var options = {
			key: fs.readFileSync($.config.item('https.key')),
			cert: fs.readFileSync($.config.item('https.cert'))
		};
		// Create the server
		var _server = https.createServer(options, function(req, res) {
			return handleServerRequest(req, res, 'https');
		});
		// Start listening....
		_server.listen($.config.item('https.port'), $.config.item('https.address'), function() {
			$.log.message('Https server running on ' + $.config.item('https.address') + ':' + $.config.item('https.port'));
		});
		return _server;
	}()),
	RequestHandle: function RequestHandle(req, res, scheme, callback) {
		// Define a timestamp property
		Object.defineProperty(this, 'timestamp', {
			value: (+new Date()),
			writable: false
		});
		// Store some basic request properties
		this.request = req;
		this.response = res;
		this.scheme = scheme;
		this.method = req.method;
		this.params = null;
		// Check for an XHR header
		this.isAjax = ((req.headers['x-requested-with'] || '').toLowerCase() === 'xmlhttprequest');
		// Parse the url
		this.url = url.parse(req.url, true);
		this._uriSegments = this.url.pathname.split('/');
		// Output to log
		$.log(
			scheme.toUpperCase() + ' ' + req.method +
			' ' + this.url.pathname +
			' (for ' + req.connection.remoteAddress + ')'
		);
		// Log the response headers
		var headers = this.requestHeaders();
		formatHeaders(headers);
		$.log.indented(2, 'Request Headers');
		$.log.indented(3, headers);
		// Data buffered for output
		this._status = 200;
		this._headers = [
			['content-type', this._schemeConfig('default_content_type')]
		];
		this._content = '';
		// POST data
		this._post      = null;
		this._postQueue = null;
		// Accept-* header value caches
		this._accept         = null;
		this._acceptEncoding = null;
		this._acceptLanguage = null;
		this._acceptCharset  = null;
		// Run any "request" plugins
		$.plugins._invoke('request', [this], callback);
	}
};

// Handles each HTTP(S) request that comes in
function handleServerRequest(req, res, scheme) {
	var handle = new RequestHandle(req, res, scheme, function() {
		try {
			var route = $._core.controllers.route(handle);
		} catch (err) {
			switch (err) {
				case $._core.controllers.noSuchController:
					handle.loadPublic();
				break;
				case $._core.controllers.noSuchRouteFunction:
					handle.raiseHttpError(404);
				break;
				case $._core.controllers.invalidMethod:
					handle.raiseHttpError(405, req.method + ' is not a valid request method for this route');
				break;
				case $._core.controllers.invalidScheme:
					handle.raiseHttpError(400, 'Cannot request this route with ' + scheme);
				break;
				default:
					throw err;
				break;
			}
		}
		if (route) {
			handle.params = route.params;
			route.func(handle);
		}
	});
}

var RequestHandle = module.exports.RequestHandle;

// Reads a value from this request's scheme's config file
RequestHandle.prototype._schemeConfig = function(item) {
	return $.config.item(this.scheme + '.' + item);
};

// Get the base URL of the application
RequestHandle.prototype.baseUrl = function() {
	return this._schemeConfig('base_url');
};

// Get the remote address
RequestHandle.prototype.remoteAddress = function() {
	if (! this._remoteAddress) {
		try {
			this._remoteAddress = this.request.headers['x-requested-for'];
		} catch (e) { }
		if (! this._remoteAddress) {
			this._remoteAddress = this.request.connection.remoteAddress;
		}
	}
	return this._remoteAddress;
};

// ------------------------------------------------------------------
//  Load the RequestHandle extensions

require($.CORE_PATH + 'input');
require($.CORE_PATH + 'output');

// ------------------------------------------------------------------
//  Helpers

function formatHeaders(headers) {
	for (var i = 0, c = headers.length; i < c; i++) {
		headers[i][0] =
			headers[i][0].replace(/(^|-)([a-z])/g, function(match) {
				return match.toUpperCase();
			}
		);
	}
}

/* End of file server.js */
/* Location: ./core/server.js */
