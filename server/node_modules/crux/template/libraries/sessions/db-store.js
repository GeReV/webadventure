/**
 * DB-based storage model
 */

// Load the class interface
var Class = require('classes').Class;

var stores = require('./stores');

var db = $.libs.require('db');
var sessionTable = db.tableName($.config.item('sessions.db_table'));

/**
 * Does a simple meta lookup
 */
module.exports.readMeta = function(id, callback) {
	modifyDatabaseSession(id, readMeta, function(err, result) {
		stores._provideMeta(err, result, callback);
	});
};

/**
 * DBStore class
 */
Class([module.exports, 'DBStore']).extends(stores.SessionStore, {
	
	init: function(onready) {
		var self = this;
		var conn = db.open();
		var callback = function(err) {
			db.close(conn);
			onready(err);
		};
		conn.select('*').from(sessionTable).where({ id: this.id }).done(function(err, result) {
			if (err) {
				return callback(err);
			}
			var storage = new stores.SessionData(self._handle);
			// Update
			if (result.length) {
				conn.update(sessionTable)
				    .set(storage.toStore(self.id))
				    .where({ id: self.id })
				    .done(callback);
			}
			// Insert
			else {
				conn.insertInto(sessionTable)
				    .values(storage.toStore(self.id, true),
				callback);
			}
		});
	},
	
	set: function(key, value, callback) {
		if (! this._addToTransaction('set', key, value)) {
			modifyDatabaseSession(this.id, function(sess) {
				return stores._set(sess.storage, key, value);
			}, callback);
		}
	},
	
	get: function(key, callback) {
		if (! this._addToTransaction('get', key, null)) {
			modifyDatabaseSession(this.id, function(sess) {
				return stores._get(sess.storage, key);
			}, callback);
		}
	},
	
	unset: function(key, callback) {
		if (! this._addToTransaction('unset', key, null)) {
			modifyDatabaseSession(this.id, function(sess) {
				return stores._unset(sess.storage, key);
			}, callback);
		}
	},
	
	destroy: function() {
		var conn = db.open();
		conn.deleteFrom(sessionTable).where({ id: this.id }).done(function(err) {
			db.close(conn);
			if (err) {throw err;}
		});
	},
	
	commitTransaction: function(callback) {
		var self = this;
		modifyDatabaseSession(this.id, function(sess) {
			var result = { };
			var store = sess.storage;
			for (var i = 0, c = self._runningTransaction.length; i < c; i++) {
				var current = self._runningTransaction[i];
				switch (current.action) {
					case 'get':
						stores._get(store, current.key, result);
					break;
					case 'set':
						stores._set(store, current.key, current.value);
					break;
					case 'unset':
						stores._unset(store, current.key);
					break;
				}
			}
			self._runningTransaction = null;
			return result;
		}, callback);
	},
	
	fetchMeta: function(callback) {
		modifyDatabaseSession(this.id, readMeta, callback);
	}
	
});

/**
 * Creates a new DBStore
 */
module.exports.create = function(id, handle, onready) {
	return new module.exports.DBStore(id, handle, onready);
};

var sessions = require('./sessions');
module.exports.cleanup = function(callback) {
	var expired = sessions.now() - sessions.conf('expires');
	var conn = db.open();
	conn.deleteFrom(sessionTable).where({ last_activity: ['<', expired] }).done(function() {
		callback();
	});
};

// ------------------------------------------------------------------

function readMeta(sess) {
	return {
		ipAddress: sess.ip_address,
		useragent: sess.user_agent,
		lastActivity: sess.last_activity
	};
}

/**
 * Reads/writes a session in the database
 */
function modifyDatabaseSession(id, func, callback) {
	var conn = db.open();
	conn.select('*').from(sessionTable).where({ id: id }).done(function(err, row) {
		if (err) {
			db.close(conn);
			return callback(err);
		}
		if (! row.length) {
			db.close(conn);
			return callback('Could not read session from database; No matching ID found');
		}
		row = row[0];
		row.storage = JSON.parse(row.storage);
		var result = func(row);
		row.storage = JSON.stringify(row.storage);
		conn.update(sessionTable).set(row).where({ id: id }).done(function(err) {
			process.nextTick(function() {
				callback((err ? err : null), result);
			});
		});
	});
}

/* End of file db-store.js */
