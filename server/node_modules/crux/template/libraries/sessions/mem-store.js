/**
 * Memory-based storage model
 */

// Load the class interface
var Class = require('classes').Class;

var storage = { };
var stores = require('./stores');

/**
 * Does a simple meta lookup
 */
module.exports.readMeta = function(id, callback) {
	stores._provideMeta(null, storage[id], callback);
};

/**
 * MemStore class
 */
Class([module.exports, 'MemStore']).extends(stores.SessionStore, {
	
	init: function(onready) {
		storage[this.id] = storage[this.id] || new stores.SessionData(this._handle);
		this._store = storage[this.id];
		onready(null);
	},
	
	set: function(key, value, callback) {
		var self = this;
		if (typeof value === 'function' && ! callback) {
			callback = value;
			value = null;
		}
		if (! this._addToTransaction('set', key, value)) {
			process.nextTick(function() {
				stores._set(self._store.storage, key, value);
				callback(null);
			});
		}
	},
	
	get: function(key, callback) {
		var self = this;
		if (! this._addToTransaction('get', key, null)) {
			process.nextTick(function() {
				callback(null,
					stores._get(self._store.storage, key)
				);
			});
		}
	},
	
	unset: function(key, callback) {
		var self = this;
		if (! this._addToTransaction('unset', key, null)) {
			process.nextTick(function() {
				stores._unset(self._store.storage, key);
				callback(null);
			});
		}
	},
	
	destroy: function() {
		destroySession(this.id);
		this._store = null;
	},
	
	commitTransaction: function(callback) {
		var result = { };
		for (var i = 0, c = self._runningTransaction.length; i < c; i++) {
			var current = self._runningTransaction[i];
			switch (current.action) {
				case 'get':
					stores._get(self._store.storage, current.key, result);
				break;
				case 'set':
					stores._set(self._store.storage, current.key, current.value);
				break;
				case 'unset':
					stores._unset(self._store.storage, current.key);
				break;
			}
		}
		self._runningTransaction = null;
		process.nextTick(function() {
			callback(null, result);
		});
	},
	
	fetchMeta: function(callback) {
		process.nextTick(function() {
			callback(null, JSON.parse(JSON.stringify(this._store.meta)));
		});
	}
	
});

/**
 * Creates a new MemStore
 */
module.exports.create = function(id, handle, onready) {
	return new module.exports.MemStore(id, handle, onready);
};

/**
 * Cleans up expired sessions
 */
module.exports.cleanup = function(callback) {
	for (var i in storage) {
		if (storage.hasOwnProperty(i) && stores.isExpired(storage[i].meta)) {
			destroySession(i);
		}
	}
	process.nextTick(callback);
};

// Destroy a session by it's id
function destroySession(id) {
	delete storage[id];
}

/* End of file mem-store.js */
