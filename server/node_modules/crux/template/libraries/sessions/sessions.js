/**
 * node-sessions
 *
 * @author     James Brumond
 * @version    0.0.0
 * @copyright  Copyright 2011 James Brumond
 * @license    Dual licensed under MIT and GPL
 *
 * Modified for use in Crux
 */

// Make sure the cookies plugin is loaded
if (! $.plugins.enabled('cookies')) {
	throw 'Cannot load sessions library; Plugin "cookies" is required.';
}

// Load the class interface
var Class = require('classes').Class;

// Load needed modules
var fs = require('fs');
var crypto = require('crypto');
var stores = require('./stores');

// Load the config file
$.config.loadSync('sessions');
var config = $.config.item('sessions');

// Opens a session
module.exports.open = function(handle, callback) {
	handle.session = new module.exports.SessionObject(handle, callback);
	return handle.session;
};

// Reads a config value
module.exports.conf = function(value) {
	return (config[value] || null);
};

// Get a timestamp to the second
module.exports.now = function() {
	return Math.round(Date.now() / 1000);
};

// The session object class
Class([module.exports, 'SessionObject'], {
	
	construct: function(handle, onready) {
		var self = this;
		
		// Store basic properties
		this.req       = handle.req;
		this.res       = handle.res;
		this._handle   = handle;
		this._cookies  = handle.cookies;
		this._onready  = async( onready || function() { } );
		
		// Fetch the store object
		fetchStore(this, function(err, store) {
			if (err) {
				return self._onready(err);
			}
			self._id    = store.id;
			self._store = store;
		});
	},
	
	get: function(key, callback) {
		return this._store.get(key, callback);
	},
	
	set: function(key, value, callback) {
		return this._store.set(key, value, callback);
	},
	
	unset: function(key, callback) {
		return this._store.unset(key, callback);
	},
	
	destroy: function() {
		return this._store.destroy();
	}
	
});

// ------------------------------------------------------------------
//  Helpers

// Generates a v4 uuid
function uuid() {
	var ret = '', value;
	for (var i = 0; i < 32; i++) {
		value = Math.random() * 16 | 0;
		// Insert the hypens
		if (i > 4 && i < 21 && ! (i % 4)) {
			ret += '-';
		}
		// Add the next random character
		ret += (
			(i === 12) ? 4 : (
				(i === 16) ? (value & 3 | 8) : value
			)
		).toString(16);
	}
	return ret;
}

// Create a session store object
function fetchStore(session, callback) {
	var handle = session._handle;
	var cookie = handle.cookies.get(config.cookie_name);
	// Creates the store and runs the callback
	var done = function(id) {
		// Write the session id to cookie
		writeSessionIdCookie(handle.cookies, id);
		// Create the store
		callback(null, stores.createStore(config.store_type, id, handle, session._onready));
	};
	// If there is a session cookie, parse out the id and
	// test it for integrity.
	if (cookie) {
		cookie = cookie.split('+');
		cookie = { raw: cookie[0], hash: cookie[1] };
		confirmSessionIntegrity(handle, cookie, function(err, id) {
			done(err ? uuid() : id.raw);
		});
	}
	// Otherwise, create a new key
	else {
		done(uuid());
	}
}

// Error codes for integrity test
var PASS               = 0;
var ERR_NO_SESSION     = 1;
var ERR_HMAC_MISMATCH  = 2;
var ERR_IP_MISMATCH    = 3;
var ERR_UA_MISMATCH    = 4;
var ERR_EXPIRED        = 5;

// Confirms the integrity of a given session and returns a uuid
function confirmSessionIntegrity(handle, id, callback) {
	// Check that the id and hash match
	if (hmacSHA1(id.raw) !== id.hash) {
		return callback(ERR_HMAC_MISMATCH);
	}
	// Calculate the meta data for the current user
	var user = (new stores.SessionData(handle)).meta;
	// Load the meta data for the given session
	stores.readMeta(config.store_type, id.raw, function(err, meta) {
		if (err || ! meta) {
			return callback(ERR_NO_SESSION);
		}
		// Compare IP addresses if required in config
		if (config.compare_ip && meta.ip_address !== user.ip_address) {
			return callback(ERR_IP_MISMATCH);
		}
		// Compare user agents if required in config
		if (config.compare_useragent && meta.useragent !== user.useragent) {
			return callback(ERR_UA_MISMATCH);
		}
		// Compare the last activity against the expire time
		if (module.exports.now() - meta.last_activity > config.expires) {
			return callback(ERR_EXPIRED);
		}
		callback(PASS, id);
	});
}

// Get an HMAC SHA1 hash string
function hmacSHA1(value) {
	var hmac = crypto.createHmac('sha1', config.private_key);
	hmac.update(value);
	return hmac.digest('hex').substring(0, 6);
}

// Get the current date plus a given number of seconds
function nowPlus(seconds) {
	return new Date(Date.now() + (seconds * 1000));
}

// Write the session cookie
function writeSessionIdCookie(cookie, id) {
	cookie.set(config.cookie_name, id + '+' + hmacSHA1(id), {
		expires: nowPlus(config.expires),
		path: config.cookie_path,
		domain: config.cookie_domain,
		secure: config.cookie_secure,
		httpOnly: config.cookie_http_only
	});
}

// Returns a function that when called will run asynchronously
function async(func) {
	return function() {
		var args = Array.prototype.slice.call(arguments);
		args.unshift(this);
		process.nextTick(func.bind.apply(func, args));
	};
}

// An automaticly running routine for cleaning up unneeded session data
(function cleanupSessions() {
	stores.cleanup(config.store_type, function() {
		setTimeout(cleanupSessions, config.cleanup_interval);
	});
}());

/* End of file node-sessions.js */
