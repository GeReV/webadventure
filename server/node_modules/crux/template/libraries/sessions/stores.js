/**
 * Interface to store classes
 */

// Load the class interface
var Class = require('classes').Class;

var STORES_PATH = './';
var METHOD_NEEDS_OVERRIDE = 'Default SessionStore methods must be overriden';

var sessions = require('./sessions');

/**
 * SessionStore class; meant to be extended to build stores
 */
Class([module.exports, 'SessionStore'], {
	
	/**
	 * Constructor
	 *
	 * @access  public
	 * @param   string    v4 uuid
	 * @param   object    request handle
	 * @param   function  callback
	 * @return  void
	 */
	construct: function(id, handle, onready) {
		Object.defineProperty(this, 'id', {
			value: id,
			writable: false
		});
		this._handle = handle;
		this._runningTransaction = null;
		this.init(onready);
	},
	
	/**
	 * Add an action to the transaction is one is running
	 *
	 * @access  public
	 * @param   string    action
	 * @param   mixed     key
	 * @param   mixed     value
	 * @return  boolean
	 */
	_addToTransaction: function(action, key, value) {
		if (! this._runningTransaction) {return false;}
		this._runningTransaction.push({
			action: action,
			key: key,
			value: value
		});
	},

	/**
	 * Initialize the session
	 *
	 * @access  public
	 * @return  void
	 */
	init: function() { throw METHOD_NEEDS_OVERRIDE; },

	/**
	 * Set a value in the store
	 *
	 * @access  public
	 * @param   mixed     the store key
	 * @param   mixed     the value
	 * @return  void
	 */
	set: function() { throw METHOD_NEEDS_OVERRIDE; },
	
	/**
	 * Get a value in the store
	 *
	 * @access  public
	 * @param   mixed     the store key
	 * @return  void
	 */
	get: function() { throw METHOD_NEEDS_OVERRIDE; },
	
	/**
	 * Remove a value in the store
	 *
	 * @access  public
	 * @param   mixed     the store key
	 * @return  void
	 */
	unset: function() { throw METHOD_NEEDS_OVERRIDE; },
	
	/**
	 * Destroy the session store
	 *
	 * Note:
	 *  May or may not be synchronous. Read as "mark for destruction".
	 *
	 * @access  public
	 * @return  void
	 */
	destroy: function() { throw METHOD_NEEDS_OVERRIDE; },
	
	/**
	 * Start a new change transaction
	 *
	 * @access  public
	 * @return  void
	 */
	startTransaction: function() {
		this._runningTransaction = [ ];
	},
	
	/**
	 * Commit a running transaction
	 *
	 * @access  public
	 * @return  void
	 */
	commitTransaction: function() { throw METHOD_NEEDS_OVERRIDE; },
	
	/**
	 * Cancel a running transaction
	 *
	 * @access  public
	 * @return  void
	 */
	cancelTransaction: function() {
		this._runningTransaction = null;
	},
	
	/**
	 * Fetches the meta data object
	 *
	 * @access  public
	 * @param   function  callback
	 * @return  void
	 */
	fetchMeta: function() { throw METHOD_NEEDS_OVERRIDE; }

});

/**
 * Session data object
 */
Class([module.exports, 'SessionData'], {
	
	meta: null,
	storage: null,
	
	construct: function(handle) {
		this.meta = {
			ipAddress: handle.remoteAddress(),
			useragent: (handle.request.headers['user-agent'] || '').substring(0, 100),
			lastActivity: sessions.now()
		};
		this.storage = { };
	},
	
	toStore: function(id, storage) {
		var result = {
			id: id,
			ip_address: this.meta.ipAddress,
			user_agent: this.meta.useragent,
			last_activity: this.meta.lastActivity
		};
		if (storage) {
			result.storage = JSON.stringify(this.storage);
		}
		return result;
	}
	
});

/**
 * Easy method for creating new store instances
 *
 * @access  public
 * @param   string    the store type (eg. "file", "mem")
 * @param   string    the session id
 * @param   object    the request handle
 * @param   function  callback
 * @return  object
 */
module.exports.createStore = function(type, id, handle, onready) {
	return require(STORES_PATH + type + '-store').create(id, handle, onready);
};

/**
 * Read meta data for a session
 *
 * @access  public
 * @param   string    the store type
 * @param   string    the session id
 * @param   function  callback
 * @return  void
 */
module.exports.readMeta = function(type, id, callback) {
	require(STORES_PATH + type + '-store').readMeta(id, callback);
};

// ------------------------------------------------------------------
//  Cleanup methods

/**
 * Cleanup expired session data
 *
 * @access  public
 * @param   string    the store type
 * @param   function  callback
 * @return  void
 */
module.exports.cleanup = function(type, callback) {
	require(STORES_PATH + type + '-store').cleanup(callback);
};

/**
 * Test if a given session is expired
 *
 * @access  public
 * @param   object    session meta data
 * @return  boolean
 */
module.exports.isExpired = function(meta) {
	return (sessions.now() - meta.lastActivity > sessions.conf('expires'));
};

// ------------------------------------------------------------------
//  Object interaction methods

// Retrieves the meta data from a session object
module.exports._provideMeta = function(err, obj, callback) {
	process.nextTick(function() {
		callback(err, (obj || null));
	});
};

// Gets a value(s) from a session store object
module.exports._get = function(obj, key, result) {
	if (Array.isArray(key)) {
		result = result || { };
		for (var i = 0, c = key.length; i < c; i++) {
			result[key[i]] = obj[key[i]];
		}
	} else if (result) {
		result[key] = obj[key];
	} else {
		result = obj[key];
	}
	return result;
};

// Set a value(s) from a session store object
module.exports._set = function(obj, key, value) {
	if (typeof key === 'object') {
		callback = value;
		for (var i in key) {
			if (key.hasOwnProperty(i)) {
				obj[i] = key[i];
			}
		}
	} else {
		obj[key] = value;
	}
};

// Unset a value(s) from a session store object
module.exports._unset = function(obj, key) {
	if (Array.isArray(key)) {
		for (var i = 0, c = key.length; i < c; i++) {
			delete obj[key[i]];
		}
	} else {
		delete obj[key];
	}
};

/* End of file stores.js */
