<h2>Database Library</h2>
<p>
	The database library currently only supports MySQL databases, but it is designed to be extended, so if you
	would like to add your own database engine, you can do that. To load the database library, you use the following.
</p>
<%- pre('code', '$.libs.require("db");') %>
<p>
	Before using the database library, you must set up the configuration file at <code>./config/db.json</code>. The
	values in there are explained pretty well. Now, let's look at an example of how you would use the database library.
</p>
<%- pre('code', [
	'// Load the database library',
	'$.libs.require("db");',
	'',
	'// Get a database connection',
	'var db = $.libs.db.open();',
	'',
	'// Run a select query',
	'db.select("*").from(db.tableName("some_table")).where({ id: 1 }).done(function(err, result) {',
	'    if (err) {throw err;}',
	'',
	'    // Output the result to the client',
	'    handle.setResponseHeader("Content-Type: text/plain");',
	'    handle.setOutput(require("util").inspect(result));',
	'    handle.send();',
	'',
	'    // Close the database connection',
	'    $.libs.db.close(db);',
	'});',
]) %>
<hr />
<h3>$.libs.db</h3>
<dl>
	
	<dt>db.open ( void )</dt>
	<dd>
		<p>
			Returns a DatabaseConnection object for interacting with the database.
		</p>
		<%- pre('code', 'var conn = db.open();') %>
	</dd>
	
	<dt>db.close ( DatabaseConnection connection )</dt>
	<dd>
		<p>
			Closes an open connection.
		</p>
		<%- pre('code', 'db.close(conn);') %>
	</dd>
	
	<dt>db.tableName ( string table )</dt>
	<dd>
		<p>
			Prefixes a table name with the given table prefix.
		</p>
		<%- pre('code', 'db.tableName("some_table"); // prefixed_some_table') %>
	</dd>
	
</dl>
<hr />
<h3>DatabaseConnection</h3>
<dl>
	
	<dt>connection.query ( string query[, array params ], function callback )</dt>
	<dd>
		<p>
			Runs a query on the database.
		</p>
		<%- pre('code', [
			'conn.query("SHOW TABLES IN ?", [db.tableName("table")], function(err, result) {',
			'    if (err) {throw err;}',
			'',
			'    // Do something with the result...',
			'',
			'});'
		]) %>
	</dd>
	
	<dt>connection.describe ( string table, function callback )</dt>
	<dd>
		<p>
			Runs a <code>DESCRIBE</code> query on the database.
		</p>
		<%- pre('code', [
			'conn.describe(db.tableName("table"), function(err, result) {',
			'    if (err) {throw err;}',
			'',
			'    // Do something with the result...',
			'',
			'});'
		]) %>
	</dd>
	
	<dt>connection.truncate ( string table, function callback )</dt>
	<dd>
		<p>
			Runs a <code>TRUNCATE</code> query on the database.
		</p>
		<%- pre('code', [
			'conn.truncate(db.tableName("table"), function(err) {',
			'    if (err) {throw err;}',
			'});'
		]) %>
	</dd>
	
	<dt>connection.showDatabases ( function callback )</dt>
	<dd>
		<p>
			Runs a <code>SHOW DATABASES</code> query on the database.
		</p>
		<%- pre('code', [
			'conn.showDatabases(function(err, result) {',
			'    if (err) {throw err;}',
			'',
			'    // Do something with the result...',
			'',
			'});'
		]) %>
	</dd>
	
	<dt>connection.showTablesIn ([ string database,] function callback )</dt>
	<dd>
		<p>
			Runs a <code>SHOW TABLES IN</code> query. If no database name is given, the one given
			in the db config file is used.
		</p>
		<%- pre('code', [
			'conn.showTablesIn(function(err, result) {',
			'    if (err) {throw err;}',
			'',
			'    // Do something with the result...',
			'',
			'});'
		]) %>
	</dd>
	
	<dt>connection.select ( mixed fields )</dt>
	<dd>
		<p>
			Starts a <code>SELECT</code> query which is built through multiple chained calls. See the
			SelectQuery section below.
		</p>
	</dd>
	
	<dt>connection.insertInto ( string table )</dt>
	<dd>
		<p>
			Starts an <code>INSERT INTO</code> query which is built through multiple chained calls. See
			the InsertQuery section below.
		</p>
	</dd>
	
	<dt>connection.createTable ( string table[, object definition ])</dt>
	<dd>
		<p>
			Starts a <code>CREATE TABLE</code> query which is built through multiple chained calls. See
			the CreateTableQuery section below.
		</p>
	</dd>
	
	<dt>connection.alterTable ( string table )</dt>
	<dd>
		<p>
			Starts an <code>ALTER TABLE</code> query which is built through multiple chained calls. See
			the AlterTableQuery section below.
		</p>
	</dd>
	
	<dt>connection.dropTable ( string table, function callback )</dt>
	<dd>
		<p>
			Runs a <code>DROP TABLE</code> query.
		</p>
		<%- pre('code', [
			'conn.dropTable(db.tableName("table"), function(err) {',
			'    if (err) {throw err;}',
			'});'
		]) %>
	</dd>
	
	<dt>connection.update ( string table )</dt>
	<dd>
		<p>
			Starts an <code>UPDATE</code> query which is built through multiple chained calls. See the
			UpdateQuery section below.
		</p>
	</dd>
	
	<dt>connection.deleteFrom ( string table )</dt>
	<dd>
		<p>
			Starts an <code>DELETE FROM</code> query which is built through multiple chained calls. See the
			DeleteFromQuery section below.
		</p>
	</dd>
	
</dl>
<hr />
<h3>SelectQuery</h3>
<p>
	A <var>SelectQuery</var> object is created when you call <var>conn.select()</var>. This object has several
	methods for building a <code>SELECT</code> query. When you are done building the query, calling <var>done()</var>
	will actually run the constructed query.
</p>
<%- pre('code', [
	'// SELECT * FROM table LIMIT 10 OFFSET 0',
	'conn.select("*").from(db.tableName("table")).limit(10).done(function(err, result) {',
	'    if (err) {throw err;}',
	'',
	'    // Do something with the results...',
	'',
	'});'
]) %>
<dl>
	
	<dt>query.from ( string table )</dt>
	<dd>
		<p>
			Sets the <code>FROM</code> clause of the query.
		</p>
	</dd>
	
	<dt>query.where ( mixed conditions )</dt>
	<dd>
		<p>
			Sets the <code>WHERE</code> clause of the query. If a string is given, it is taken as the literal value
			of the clause. If an object is given, the properties of the object are used to build the clause. Property
			values that are strings are used as equality tests (eg. <code>{ foo: 'bar' }</code> becomes <code>foo='bar'</code>).
			If a property value is an array, the first value of the array is used as the operator and the second value
			is used as the test value (eg. <code>{ foo: ['>', 2] }</code> becomes <code>foo>2</code>). Multiple properties
			are joined by <code>AND</code> operators.
		</p>
		<%- pre('code', [
			'// SELECT ... WHERE foo=\'bar\'',
			'conn.select...where("foo=\'bar\'");',
			'',
			'// SELECT ... WHERE a=1 AND b>=2',
			'conn.select...where({',
			'    a: 1,',
			'    b: [">=", 2]',
			'});'
		]) %>
	</dd>
	
	<dt>query.orderBy ( string column[, string order = 'ASC' ])</dt>
	<dd>
		<p>
			Sets the <code>ORDER BY</code> clause of the query.
		</p>
	</dd>
	
	<dt>query.limit ([ number offset = 0,] number rowCount )</dt>
	<dd>
		<p>
			Sets the <code>LIMIT/OFFSET</code> clause of the query.
		</p>
	</dd>
	
	<dt>query.done ( function callback )</dt>
	<dd>
		<p>
			Runs the query.
		</p>
	</dd>
	
</dl>
<hr />
<h3>InsertQuery</h3>
<p>
	An <var>InsertQuery</var> object is created when you call <var>conn.insert()</var>. There are two ways that
	you can build an <code>INSERT</code> query. The first is a simple <code>INSERT INTO ... VALUE</code> format.
	You can also use the <code>INSERT INTO ... SELECT</code> format as well.
</p>
<dl>
	
	<dt>query.values ( object values, function callback )</dt>
	<dd>
		<p>
			The <var>values</var> method takes an object containing the data to insert into the table or an array
			of objects (to insert multiple rows).
		</p>
		<%- pre('code', [
			'// INSERT INTO table (foo,some) VALUES (\'bar\',\'stuff\')',
			'conn.insertInto(db.tableName("table")).values({',
			'    foo: "bar",',
			'    some: "stuff"',
			'});'
		]) %>
	</dd>
	
	<dt>query.select ( string fields )</dt>
	<dd>
		<p>
			Builds a <code>INSERT INTO ... SELECT</code> query. Returns a SelectQuery object that.
		</p>
		<%- pre('code', [
			'var table = db.tableName("table");',
			'var other = db.tableName("other");',
			'',
			'conn.insertInto(table).select(["foo", "bar"]).from(other).done(function(err, result) {',
			'    if (err) {throw err;}',
			'',
			'    // Do something with the results...',
			'',
			'});'
		]) %>
	</dd>
	
</dl>
<hr />
<h3>CreateTableQuery</h3>
<p>
	Running the <var>conn.createTable()</var> method creates a <var>CreateTableQuery</var> object. This
	method requires a table name for the new table to create and, optionally, an object defining the table.
	The definition object looks like this:
</p>
<%- pre('code', [
	'{',
	'    field_name: {',
	'        type: "INT(4)",        // The field type',
	'        notNull: true,         // Should a NOT NULL be added (default: false)',
	'        autoIncrement: false,  // Should an AUTO_INCREMENT be added (default: false)',
	'        default: 0,            // The default value (default: <em>none</em>)',
	'        unique: true,          // Should a UNIQUE be added (default: false)',
	'        primary: false,        // Is this the table\'s primary key?',
	'        foreign: false         // Foreign key definition',
	'    }',
	'    ...',
	'}'
]) %>
<p>
	If a field is to be a foreign key, the <var>foreign</var> property should follow this format:
</p>
<%- pre('code', [
	'{',
	'    references: ["table", "field"],',
	'    onDelete: "CASCADE"',
	'}'
]) %>
<dl>
	
	<dt>query.ifNotExists ( object definition )</dt>
	<dd>
		<p>
			You can choose to not give your definition object to <var>conn.createTable</var> and instead
			use this method to create an <code>IF NOT EXISTS</code> clause in your query.
		</p>
		<%- pre('code', [
			'// CREATE TABLE IF NOT EXISTS table ...',
			'conn.createTable("table").ifNotExists({ ... })'
		]) %>
	</dd>
	
	<dt>query.engine ( string engine )</dt>
	<dd>
		<p>
			Sets the database engine to use for this table.
		</p>
		<%- pre('code', [
			'// CREATE TABLE table (...) ENGINE=InnoDB',
			'conn.createTable("table", ...).engine("InnoDB")'
		]) %>
	</dd>
	
	<dt>query.done ( function callback )</dt>
	<dd>
		<p>
			Runs the query when you are done building it.
		</p>
	</dd>
	
</dl>
<hr />
<h3>AlterTableQuery</h3>
<p>
	Currently, the <code>ALTER TABLE</code> query object only supports one method, <var>addColumn</var>.
</p>
<dl>
	
	<dt>query.addColumn ( string column, object definition, function callback )</dt>
	<dd>
		<p>
			Adds a new column to the table. The definition object is the same format as the one used in
			the <var>createTable</var> function.
			<%- pre('code', [
				'var def = {',
				'    ...',
				'};',
				'conn.alterTable("table").addColumn("column", def, function(err) {',
				'    ',
				'    ...',
				'',
				'});'
			]) %>
		</p>
	</dd>
	
</dl>
<hr />
<h3>UpdateQuery</h3>
<p>
	The <var>UpdateQuery</var> object is used in creating <code>UPDATE</code> queries.
</p>
<dl>
	
	<dt>query.set ( object values )</dt>
	<dd>
		<p>
			Takes an object containing column/value pairs for the new values to set.
		</p>
	</dd>
	
	<dt>query.where ( mixed conditions )</dt>
	<dd>
		<p>
			Builds the <code>WHERE</code> clause of the query. The conditions argument is the same as the
			one given for <code>SELECT</code> queries.
		</p>
	</dd>
	
	<dt>query.orderBy ( string column[, string order = 'ASC' ])</dt>
	<dd>
		<p>
			Builds the <code>ORDER BY</code> clause of the query.
		</p>
	</dd>
	
	<dt>query.limit ( number rowCount )</dt>
	<dd>
		<p>
			Builds the <code>LIMIT</code> clause of the query.
		</p>
	</dd>
	
	<dt>query.done ( function callback )</dt>
	<dd>
		Sends the query and handles the response.
	</dd>
	
</dl>
<hr />
<h3>DeleteFromQuery</h3>
<p>
	Deletes rows from a database table.
</p>
<dl>
	
	<dt>query.where ( mixed conditions )</dt>
	<dd>
		<p>
			Builds the <code>WHERE</code> clause of the query. The conditions argument is the same as the
			one given for <code>SELECT</code> queries.
		</p>
	</dd>
	
	<dt>query.orderBy ( string column[, string order = 'ASC' ])</dt>
	<dd>
		<p>
			Builds the <code>ORDER BY</code> clause of the query.
		</p>
	</dd>
	
	<dt>query.limit ( number rowCount )</dt>
	<dd>
		<p>
			Builds the <code>LIMIT</code> clause of the query.
		</p>
	</dd>
	
	<dt>query.done ( function callback )</dt>
	<dd>
		Sends the query and handles the response.
	</dd>

</dl>
<hr />
<h3>Avoiding Callback Hell</h3>
<p>
	As you can see, every last one of these query methods is asynchronous and relies on callbacks to provide
	you with results. If you are running more than one query in a row, this can get very ugly, very fast as
	you nest callback inside of callback. To avoid this, there are some extra helper methods called transaction
	methods to build up a list of queries and run them with a single callback (no, this does not use native
	transactions like those used in MySQL; This is a feature of the database library that simply queues up
	queries to run; <em>It provides no transaction security at all</em>. If you need native transactions, use
	the <var>conn.query</var> method to start/end your transaction before and after the library transaction
	methods).
</p>
<p>
	Now, let's look at how these transaction methods. There are two ways to use the database library's transaction
	feature: with seperate start/stop calls (which does not require an extra callback level) or a single method
	that usually is more readable (in my opinion, at least), but requires an extra callback. The first way uses
	the method <var>conn.startTransaction</var> to begin and <var>conn.commitTransaction</var> to send the
	queries to the database (there is also <var>conn.rollbackTransaction</var> to unqueue the queries and
	cancel the transaction).
</p>
<%- pre('code', [
	'// Get a database connection',
	'var conn = db.open();',
	'',
	'// Start the transaction',
	'conn.startTransaction();',
	'',
	'// Queue up some queries',
	'conn.query(...);',
	'conn.query(...);',
	'',
	'// Run the queries and get the results',
	'conn.commitTransaction(function(err, results, queries) {',
	'',
	'    // If an error occured, the queries stop running and the error',
	'    // is passed in as the first parameter. The second parameter is',
	'    // an array of results from each query. The third parameter is an',
	'    // array of the SQL queries that were run.',
	'',
	'    db.close(conn);',
	'});',
]) %>
<p>
	The second version wraps the whole process in a callback to make the transaction clearly readable. It uses the
	<var>conn.runTransaction</var> method.
</p>
<%- pre('code', [
	'// Get a database connection',
	'var conn = db.open();',
	'',
	'// Start the transaction',
	'conn.runTransaction(function(commit, rollback) {',
	'',
	'    // Queue up some queries',
	'    conn.query(...);',
	'    conn.query(...);',
	'',
	'    // Run the queries and get the results',
	'    commit(function(err, results, queries) {',
	'',
	'        // The arguments to this are the same as the ones above.',
	'',
	'        db.close(conn);',
	'    });',
	'',
	'});'
]) %>
