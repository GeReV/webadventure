<h2>MVC Structure</h3>
<p>
	Crux uses an <abbr title="Model/View/Controller">MVC</abbr> structure for organizing code. Controllers are
	files that, well, control. When a request comes in to the server, it is passed off to a controller to handle.
	You should have two controller files: <code>guide.js</code> (which is used for displaying this user guide) and
	<code>welcome.js</code> (which is what displays the welcome message). We do not want to mess with the guide
	as we are kind of reading it right now and do not want to break it. So, let's look at <code>welcome.js</code>.
</p>
<%- pre('code', [
	'/**',
	' * The example controller file',
	' */',
	'',
	'module.exports = {',
	'',
	'	// Nice and simple, this is the default route.',
	'	// We will use it for our welcoming page.',
	'	index: function(handle) {',
	'		handle.renderView(\'welcome\', { }, true, function() {',
	'			handle.send();',
	'		});',
	'	}',
	'',
	'};',
	'',
	'/* End of file welcome.js */',
	'/* Location: ./controllers/welcome.js */'
]) %>
<p>
	As you can see, the controller has a function in it which is intended to do something, but how do we invoke
	this function? Controllers are referenced by the first segment in the request URI. For example, if a request
	was made to <kbd>/welcome</kbd> we would reach the controller <code>welcome.js</code>. We then access
	individual functions in the controller using the second segment of the URI, so <kbd>/welcome/index</kbd>
	run the function <var>index</var> in the controller <code>welcome.js</code>. It should also be noted that
	if no second segment is given the controller defaults to running the function <var>index</var> if there is
	one and if no URI segments are given the controller will be decided by the value <var>default_controller</var>
	in the HTTP(S) configuration file.
</p>
<hr />
<h3>The handle Object and View Rendering</h3>
<p>
	When a controller function is called, it is given an object as a parameter. This object contains information
	about the request and is the way that you send a response. You can see above that we call a method called
	<var>handle.renderView</var>. This function loads a file called a view file from the directory <code>views</code>
	and outputs the contents to the client. These view files can be simple text files (such as HTML content), but
	they can also contain templating code that allows you to build the content dynamically. This templating is done
	using a Node module called <a href="https://github.com/visionmedia/ejs">EJS</a>. The templating code is contained
	in the view files using special tags that look like <code>&lt;%</code> and <code>%&gt;</code>. For example, the
	following could be used as a view file.
</p>
<%- pre('code', [
	'<\% for (var i = 0; i < 10; i++) { %\>',
	'Hello, World!',
	'<\% } %\>'
]) %>
<p>
	When rendered, this view file would say "Hello, World!" ten times. You can also use a <code>&lt;%-</code> tag to
	output from your code directory to the view like this, which would render the numbers 0-9.
</p>
<%- pre('code', [
	'<\% for (var i = 0; i < 10; i++) { %\>',
	'<\%- i %\>',
	'<\% } %\>'
]) %>
<p>
	The syntax for the <var>renderView</var> method looks like this:
</p>
<%- pre('void handle.renderView ( string view, object data, boolean forceFresh, function callback )') %>
<p>
	The first parameter is the name of the view file to load, so to load <code>./views/mine.ejs</code>, you would
	give a first parameter of <code>"mine"</code>. The second parameter is an object containing data to pass to the
	view file. For example, if you gave the object <code>{ foo: 'bar' }</code>, then you could use the variable
	<code>foo</code> in your view (by the way, you can access the handle object in your view files using <code>this</code>;
	There is no need to pass it in). The third parameter is a flag that sets whether the view should be re-read from
	file each time it is needed. By default, Crux caches the contents of view files to enable faster rendering, but
	by passing in <code>true</code> you will force it to read the contents from file (note that caching does not
	cache the result of the EJS rendering, just the contents of the file; The embedded JavaScript code will be re-run
	everytime regardless). The final parameter is a callback function that is called after the view has been rendered
	and buffered for output. Crux does not actually output anything to the client until you call the method
	<var>handle.send()</var> (which is why we call <var>send</var> in the callback in the welcome controller).
</p>
<p>
	You can also force a view to render synchronously using the method <var>renderViewSync</var> which takes the
	same parameters (except there is no need for a callback). This is not usually recomended as it requires Node to
	stop handling other requests which reading the view file, but it is necessary for embedding views inside of each
	other (unless you want to do some really wierd stuff...).
</p>
<p>
	While we are on the topic of views, it should be noted that there is one view file that you have to have, and that
	is the file <code>./views/error.ejs</code>. This is the file that is used to handle HTTP errors such as 404 Not Found
	errors and 500 Internal Server Errors. When such an error occurs, the error view is rendered and output automatically.
	The view will be given three variables: <var>errorStatus</var>, <var>errorName</var>, and <var>errorMessage</var>.
	You can also manually invoke such an error by throwing a special type of object and letting it bubble to the top or
	by calling the <var>raiseHttpError</var> method.
</p>
<%- pre('code', [
	'// Using throw',
	'throw handle.httpError(404, \'We could not find that file\');',
	'',
	'// Using raiseHttpError (this way you don\'t have throw killing your',
	'// currently running code, which may or may not be what you want)',
	'handle.raiseHttpError(500, \'There was an error in our code\');'
]) %>
<hr />
<h3>Models</h3>
<p>
	The last component to the MVC structure are models, which are used to manage data and behavior. For example, if you
	were building a blog, you might have a model that reads and writes data abouts posts from/to your database. You store
	models in the <code>./models</code> directory and load them using <var>$.models.require</var>. In Crux, there is a
	global object <var>$</var> which controls the interaction of different core components (like the servers, the plugins
	system, and logging). The <var>$.models</var> object is where models are stored after they are loaded. So, if you had
	a model called <var>foo</var> with a method <var>bar</var> you could use it like this.
</p>
<%- pre('code', [
	'$.models.require("foo");',
	'$.models.foo.bar();',
]) %>
<p>
	The <var>require</var> method also returns the loaded model, so you could shorten that in a couple ways.
</p>
<%- pre('code', [
	'// Store the model in a variable',
	'var foo = $.models.require("foo");',
	'foo.bar();',
	'',
	'// Chain the method to require',
	'$.models.require("foo").bar();'
]) %>
<p>
	Models are very simple constructs in Crux; They are just Node modules. There is nothing special about how
	they are built or how they work. You just attach properties to <var>exports</var>.
</p>
<%- pre('code', [
	'exports.bar = function() {',
	'    // do stuff...',
	'};'
]) %>
<hr />
<h3>Public Files</h3>
<p>
	If a request is made and there is not matching route, Crux will attempt to load a file from the directory
	<code>./public</code> and serve it to the client. For example, if you request <kbd>/some/file</kbd> and there
	is no controller to handle that request, it will attempt to load a file <code>./public/some/file</code> and
	only if that file does not exist will it raise a 404 error. This is most useful for serving static files like
	CSS, JavaScript, and media files.
</p>
<hr />
<h3>More About Controllers</h3>
<p>
	You can be more specific in your contollers then just providing functions for routes; You can also specify different
	functions for different request methods or schemes.
</p>
<%- pre('code', [
	'module.exports = {',
	'',
	'    route_one: {',
	'        get: function(handle) {',
	'            // This function handles GET requests only',
	'        },',
	'        post: function(handle) {',
	'            // This function handles POST requests only',
	'        },',
	'',
	'        any: {',
	'            http: function(handle) {',
	'                // This function handles any other method, but only for http',
	'            },',
	'            https: function(handle) {',
	'                // This function handles any other method, but only for https',
	'            }',
	'        }',
	'',
	'    }',
	'',
	'};'
]) %>
<p>
	As of version 0.3.1, Crux supports pattern-based routing. To use this feature, you must first enable it in the
	<code>core.json</code> config file. For an example of pattern-based routing, let's say you have a controller
	that represents items in a shopping cart system. It would be very common in such a case to need to get an item
	ID.
</p>
<%- pre('code', [
	'/**',
	' * A shopping cart item controller',
	' */',
	'',
	'module.exports = {',
	'',
	'    // Get the shopping cart info',
	'    ":id": {',
	'        get: function(handle) {',
	'            var itemId = handle.params.id;',
	'        }',
	'    }',
	'',
	'};',
	'',
	'/* End of file item.js */',
	'/* Location: ./controllers/item.js */'
]) %>
<p>
	The <code>:id</code> matches any one URI segment and stores it's value in <var>handle.params</var> under the
	property <var>id</var>. Therefore, you could request any of the following routes: <code>/item/123</code>,
	<code>/item/09876</code>, <code>/item/foo</code>. You can also use more complex routes with multiple params,
	like <code>":id/do/:action"</code> which could match things like <code>/item/123/do/purchase</code>.
</p>
<p>
	When you use pattern routing, you can still use simple routes like <code>index</code>, but there are some
	things that should be noted. First, when pattern routing is enabled, only exact matches are valid. For example,
	without pattern routing, <code>index</code> would match the route <code>/controller/index/foo/bar</code>, but
	when pattern routing is enabled it will only match <code>/controller/index</code> (or just <code>/controller</code>).
	Also, if multiple patterns match a route (eg. <code>"foo"</code> and <code>":id"</code> would both match the
	route <code>/controller/foo</code>), the first one declared in the file will always take precedence.
</p>
